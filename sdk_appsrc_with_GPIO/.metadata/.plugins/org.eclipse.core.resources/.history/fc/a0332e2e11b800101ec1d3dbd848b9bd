///************************************************************************/
///*																		*/
///*	demo.c	--	Zedboard DMA Demo				 						*/
///*																		*/
///************************************************************************/
///*	Author: Sam Lowe											*/
///*	Copyright 2015, Digilent Inc.										*/
///************************************************************************/
///*  Module Description: 												*/
///*																		*/
///*		This file contains code for running a demonstration of the		*/
///*		DMA audio inputs and outputs on the Zedboard.					*/
///*																		*/
///*																		*/
///************************************************************************/
///*  Notes:																*/
///*																		*/
///*		- The DMA max burst size needs to be set to 16 or less			*/
///*																		*/
///************************************************************************/
///*  Revision History:													*/
///* 																		*/
///*		8/23/2016(SamL): Created										*/
///*																		*/
///************************************************************************/
//
//
//#include "demo.h"
//
//
//
//
//#include "./audio/audio.h"
//#include "./dma/dma.h"
//#include "./intc/intc.h"
//#include "./userio/userio.h"
//
//#include "./iic/iic.h"
//#include "./kws/kws_engine.h"
//
///***************************** Include Files *********************************/
//#include "ff.h"
//#include "xil_cache.h"
//
//#include "xaxidma.h"
//
//#include "xparameters.h"
//#include "xil_exception.h"
//#include "xdebug.h"
//#include "xiic.h"
//#include "xaxidma.h"
//#include <stdint.h>
//
//
//
//#ifdef XPAR_INTC_0_DEVICE_ID
// #include "xintc.h"
// #include "microblaze_sleep.h"
//#else
// #include "xscugic.h"
//#include "sleep.h"
//#include "xil_cache.h"
//#endif
//
//// 音频录制
//static FATFS fs;
//static FIL fil;
//static int rec_index = 0;
//// === 写入SD卡 ===
//FRESULT fr;
///************************** Constant Definitions *****************************/
//
///*
// * Device hardware build related constants.
// */
//
//// Audio constants
//// Number of seconds to record/playback
//// store 1s, playback 1s
////#define NR_SEC_TO_REC_PLAY		1
//#define I2S_BYTES_PER_FRAME	5U
//static int32_t sign_extend_20bit(uint32_t value)
//{
//    if (value & 0x80000U) {
//        value |= 0xFFF00000U;
//    }
//    return (int32_t)value;
//}
//
////static void unpack_i2s_frames_to_q31(const uint8_t *src,
////                                    size_t frames,
////                                    int32_t *dst)
////{
////    for (size_t i = 0U; i < frames; ++i) {
////        size_t byte_idx = i * I2S_BYTES_PER_FRAME;
////        uint32_t b0 = src[byte_idx + 0U];
////        uint32_t b1 = src[byte_idx + 1U];
////        uint32_t b2 = src[byte_idx + 2U];
////        uint32_t b3 = src[byte_idx + 3U];
////        uint32_t b4 = src[byte_idx + 4U];
////
////        uint32_t left_u = (b0 << 12) | (b1 << 4) | (b2 >> 4);
////        uint32_t right_u = ((b2 & 0x0FU) << 16) | (b3 << 8) | b4;
////
////        int32_t left = sign_extend_20bit(left_u) << 12;
////        int32_t right = sign_extend_20bit(right_u) << 12;
////
////        int64_t mono = ((int64_t)left + (int64_t)right) / 2;
////        dst[i] = (int32_t)mono;
////    }
////}
//// 注意小端系统
//static void unpack_i2s_frames_to_q31_le_safe(const uint8_t *src,
//                                             size_t frames,
//                                             int32_t *dst)
//{
//    if (frames == 0) return;
//
//    /* 自动检测是否字节反序：看前5字节的高位是否像MSB-first */
//    uint8_t b0 = src[0], b4 = src[4];
//    int reversed = (b0 < b4);
//    // 一般语音波形高位(MSB)先出，大部分时间 |b0| > |b4|；如果反了则 reversed=1
//
//    if (reversed)
//        xil_printf("[I2S] Detected reversed byte order (DMA little-endian)\r\n");
//    else
//        xil_printf("[I2S] Detected normal byte order (I2S big-endian stream)\r\n");
//
//    for (size_t i = 0U; i < frames; ++i)
//    {
//        size_t idx = i * I2S_BYTES_PER_FRAME;
//        uint32_t b0, b1, b2, b3, b4;
//
//        if (!reversed)
//        {
//            /* I2S标准顺序：MSB先出 */
//            b0 = src[idx + 0];
//            b1 = src[idx + 1];
//            b2 = src[idx + 2];
//            b3 = src[idx + 3];
//            b4 = src[idx + 4];
//        }
//        else
//        {
//            /* 小端写入反序 */
//            b4 = src[idx + 0];
//            b3 = src[idx + 1];
//            b2 = src[idx + 2];
//            b1 = src[idx + 3];
//            b0 = src[idx + 4];
//        }
//
//        /* 拼左声道 (b0,b1,b2[7:4]) */
//        uint32_t left_u  = (b0 << 12) | (b1 << 4) | (b2 >> 4);
//        /* 拼右声道 (b2[3:0],b3,b4) */
//        uint32_t right_u = ((b2 & 0x0F) << 16) | (b3 << 8) | b4;
//
//        /* 符号扩展并左移成Q31 */
//        int32_t left  = sign_extend_20bit(left_u)  << 12;
//        int32_t right = sign_extend_20bit(right_u) << 12;
//
//        /* 混成立体声 → 单声道 */
//        int64_t mono = ((int64_t)left + (int64_t)right) / 2;
//        dst[i] = (int32_t)mono;
//    }
//}
//
//// 淇敼褰曢煶闀垮害锛屾坊鍔犱竴涓ǔ瀹氭椂闂�0.1s
//#define BIAS_SEC 0.1f  // 鍋忕疆绋冲畾鏃堕暱 0.1 绉�
//#define NR_SEC_TO_REC_PLAY		(1.0f + BIAS_SEC)
//// 鎸夐敭鏃堕棿
//#define KWS_VALID_SEC  1U
//// ADC/DAC sampling rate in Hz
////#define AUDIO_SAMPLING_RATE		1000
//#define AUDIO_SAMPLING_RATE	  96000
//#define AUDIO_SAMPLE_BYTES	  5U
//#define KWS_SAMPLE_BYTES	  4U
//// Number of samples to record/playback
//#define NR_AUDIO_SAMPLES		((int)(NR_SEC_TO_REC_PLAY*AUDIO_SAMPLING_RATE))
//// KWS鐨勯噰鏍烽鐜囨槸16000
//#define NR_KWS_SAMPLES          ((int)(KWS_VALID_SEC*KWS_SOURCE_SAMPLE_RATE))
//// 涔樹互5鏄洜涓�32浣嶄綅瀹戒箻浠ヨ�虫満鍙岄�氶亾
//#define KWS_DMA_TRANSFER_BYTES		(AUDIO_SAMPLE_BYTES * NR_AUDIO_SAMPLES)
//
///* Timeout loop counter for reset
// */
//#define RESET_TIMEOUT_COUNTER	10000
//
//#define TEST_START_VALUE	0x0
//// 闇�瑕佸闊抽杩涜闄嶉噰鏍�
//static int32_t gMicMonoBuffer[NR_AUDIO_SAMPLES];
//static int32_t gKwsInputBuffer[NR_KWS_SAMPLES];
//
///**************************** Type Definitions *******************************/
//#define AUDIO_FRAME_STRIDE	  KWS_SOURCE_CHANNELS // 1U
//
////#define AUDIO_BUFFER_BYTES	  ((size_t)NR_SEC_TO_REC_PLAY * AUDIO_SAMPLING_RATE * AUDIO_FRAME_STRIDE * AUDIO_SAMPLE_BYTES)
//// KWS transfer
///* 绠�鍗曞钩鍧� 6 鐐归檷閲囨牱锛屽彲鍦� PS 绔疄鏃惰繍琛� */
//#define DOWNSAMPLE_RATIO 6
//static void downsample_6x_avg(const int32_t *in, int32_t *out, int input_samples) {
//    int output_samples = input_samples / DOWNSAMPLE_RATIO;
//    for (int i = 0; i < output_samples; ++i) {
//        int64_t sum = 0;
//        for (int j = 0; j < DOWNSAMPLE_RATIO; ++j)
//            sum += in[i * DOWNSAMPLE_RATIO + j];
//        out[i] = (int32_t)(sum / DOWNSAMPLE_RATIO);
//    }
//}
///***************** Macros (Inline Functions) Definitions *********************/
//
//
///************************** Function Prototypes ******************************/
//#if (!defined(DEBUG))
//extern void xil_printf(const char *format, ...);
//#endif
//
///**
// * @brief 点亮指定编号的LED（其余LED熄灭）
// * @param psGpio   已初始化的GPIO实例指针
// * @param ledIndex 要点亮的LED编号 (0~7)
// */
//void fnSetSingleLed(XGpio *psGpio, u8 ledIndex)
//{
//    u32 led_value = 0x00;
//    if (ledIndex < 8) {
//        led_value = (1 << ledIndex);  // 只点亮对应LED
//        xil_printf("LED = %d\r\n", led_value);
//    } else {
//        xil_printf("LED index out of range (0-7)\r\n");
//    }
//
//    XGpio_DiscreteWrite(psGpio, LED_CHANNEL, led_value);
//}
//
//
///************************** Variable Definitions *****************************/
///*
// * Device instance definitions
// */
//
//static XIic sIic;
//static XAxiDma sAxiDma;		/* Instance of the XAxiDma */
//
//static XGpio sUserIO;
//
//volatile sDemo_t Demo = {0};
//
//#ifdef XPAR_INTC_0_DEVICE_ID
// static XIntc sIntc;
//#else
// static XScuGic sIntc;
//#endif
//
////
//// Interrupt vector table
//#ifdef XPAR_INTC_0_DEVICE_ID
//const ivt_t ivt[] = {
//	//IIC
//	{XPAR_AXI_INTC_0_AXI_IIC_0_IIC2INTC_IRPT_INTR, (XInterruptHandler)XIic_InterruptHandler, &sIic},
//	//DMA Stream to MemoryMap Interrupt handler
//	{XPAR_AXI_INTC_0_AXI_DMA_0_S2MM_INTROUT_INTR, (XInterruptHandler)fnS2MMInterruptHandler, &sAxiDma},
//	//DMA MemoryMap to Stream Interrupt handler
//	{XPAR_AXI_INTC_0_AXI_DMA_0_MM2S_INTROUT_INTR, (XInterruptHandler)fnMM2SInterruptHandler, &sAxiDma},
//	//User I/O (buttons, switches, LEDs)
//	{XPAR_AXI_INTC_0_AXI_GPIO_0_IP2INTC_IRPT_INTR, (XInterruptHandler)fnUserIOIsr, &sUserIO}
//};
//#else
//const ivt_t ivt[] = {
//	//IIC
//	{XPAR_FABRIC_AXI_IIC_0_IIC2INTC_IRPT_INTR, (Xil_ExceptionHandler)XIic_InterruptHandler, &sIic},
//	//DMA Stream to MemoryMap Interrupt handler
//	{XPAR_FABRIC_AXI_DMA_0_S2MM_INTROUT_INTR, (Xil_ExceptionHandler)fnS2MMInterruptHandler, &sAxiDma},
//	//DMA MemoryMap to Stream Interrupt handler
//	{XPAR_FABRIC_AXI_DMA_0_MM2S_INTROUT_INTR, (Xil_ExceptionHandler)fnMM2SInterruptHandler, &sAxiDma},
//	//User I/O (buttons, switches, LEDs)
//	{XPAR_FABRIC_AXI_GPIO_0_IP2INTC_IRPT_INTR, (Xil_ExceptionHandler)fnUserIOIsr, &sUserIO}
//};
//#endif
//
//
///*****************************************************************************/
///**
//*
//* Main function
//*
//* This function is the main entry of the interrupt test. It does the following:
//*	Initialize the interrupt controller
//*	Initialize the IIC controller
//*	Initialize the User I/O driver
//*	Initialize the DMA engine
//*	Initialize the Audio I2S controller
//*	Enable the interrupts
//*	Wait for a button event then start selected task
//*	Wait for task to complete
//*
//* @param	None
//*
//* @return
//*		- XST_SUCCESS if example finishes successfully
//*		- XST_FAILURE if example fails.
//*
//* @note		None.
//*
//******************************************************************************/
//int main(void)
//{
//	int Status;
//
//	Demo.u8Verbose = 1;
//	Demo.fKwsEngineReady = 0;
//	Demo.fKwsResultValid = 0;
//	Demo.u32KwsClass = 0;
//	Demo.fKwsConfidence = 0.0f;
//
//	//Xil_DCacheDisable();
//
//	xil_printf("\r\n--- Entering main() --- \r\n");
//
//
//	//
//	//Initialize the interrupt controller
//
//	Status = fnInitInterruptController(&sIntc);
//	if(Status != XST_SUCCESS) {
//		xil_printf("Error initializing interrupts");
//		return XST_FAILURE;
//	}
//
//
//	// Initialize IIC controller
//	Status = fnInitIic(&sIic);
//	if(Status != XST_SUCCESS) {
//		xil_printf("Error initializing I2C controller");
//		return XST_FAILURE;
//	}
//
//    // Initialize User I/O driver
//    Status = fnInitUserIO(&sUserIO);
//    if(Status != XST_SUCCESS) {
//    	xil_printf("User I/O ERROR");
//    	return XST_FAILURE;
//    }
//
//
//	//Initialize DMA
//	Status = fnConfigDma(&sAxiDma);
//	if(Status != XST_SUCCESS) {
//		xil_printf("DMA configuration ERROR");
//		return XST_FAILURE;
//	}
//
//
//	//Initialize Audio I2S
//	Status = fnInitAudio();
//	if(Status != XST_SUCCESS) {
//		xil_printf("Audio initializing ERROR");
//		return XST_FAILURE;
//	}
//
//
//	// Enable all interrupts in our interrupt vector table
//	// Make sure all driver instances using interrupts are initialized first
//	fnEnableInterrupts(&sIntc, &ivt[0], sizeof(ivt)/sizeof(ivt[0]));
//	// initial KwsEngine
//	Status = KwsEngine_Initialize(KWS_DEFAULT_WEIGHT_PATH);
//
//	if(Status == XST_SUCCESS) {
//		Demo.fKwsEngineReady = 1;
//		xil_printf("\r\nKWS engine initialization successful;\r\n");
//	} else {
//		xil_printf("\r\nKWS engine initialization failed; inference disabled\r\n");
//		return Status;
//	}
//
////	Status = KwsEngine_Initialize(KWS_DEFAULT_WEIGHT_PATH);
//
////	if(Status == XST_SUCCESS) {
////		Demo.fKwsEngineReady = 1;
////	} else {
////		xil_printf("\r\nKWS engine initialization failed; inference disabled\r\n");
////	}
//
////	Status = KwsEngine_Initialize(KWS_DEFAULT_WEIGHT_PATH);
///*	if(Status == XST_SUCCESS) {
//		Demo.fKwsEngineReady = 1;
//	} else {
//		xil_printf("\r\nKWS engine initialization failed; inference disabled\r\n");
//	}*/
//
//    xil_printf("\r\nInitialization done");
//    xil_printf("\r\n");
//    xil_printf("\r\nControls:");
//    xil_printf("\r\n    BTNL: Play recording on LINE OUT");
//    xil_printf("\r\n    BTNU: Record from MIC IN");
//    xil_printf("\r\n    BTND: Play recording on HPH OUT");
//    xil_printf("\r\n    BTNR: Record from LINE IN");
//
//    //main loop
//
//    while(1) {
//
////    	fnSetSingleLed(&sUserIO, 2);
//
////    	xil_printf("----------------------------------------------------------\r\n");
////		xil_printf("Genesys 2 DMA Audio Demo\r\n");
////		xil_printf("----------------------------------------------------------\r\n");
//
//    	//Xil_DCacheDisable();
//
//    	// Checking the DMA S2MM event flag
//			if (Demo.fDmaS2MMEvent)
//			{
//				xil_printf("\r\nRecording Done...");
//
//				// Disable Stream function to send data (S2MM)
//				Xil_Out32(I2S_STREAM_CONTROL_REG, 0x00000000);
//				Xil_Out32(I2S_TRANSFER_CONTROL_REG, 0x00000000);
//				//Flush cache
//				Xil_DCacheInvalidateRange((u32) MEM_BASE_ADDR, KWS_DMA_TRANSFER_BYTES);
//
//				const int engine_ready = (Demo.fKwsEngineReady != 0U) && (KwsEngine_IsReady() != 0);
//				xil_printf("\r\n Demo_KWS_Ready = %d \r\n", engine_ready);
//				xil_printf("\r\n Demo.fKwsEngineReady = %d \r\n", Demo.fKwsEngineReady);
//				xil_printf("\r\n KwsEngine_IsReady = %d \r\n", KwsEngine_IsReady());
//				if (engine_ready)
//				{
//					Demo.fKwsResultValid = 0;
//					const size_t total_frames = KWS_DMA_TRANSFER_BYTES / I2S_BYTES_PER_FRAME;
//					const size_t offset_frames = (size_t)(AUDIO_SAMPLING_RATE * BIAS_SEC);
//					const size_t available_frames = (total_frames > offset_frames) ? (total_frames - offset_frames) : 0U;
//					const size_t required_frames = (size_t)NR_KWS_SAMPLES * DOWNSAMPLE_RATIO;
//
//					if (available_frames >= required_frames)
//					{
//						const uint8_t *dma_bytes = (const uint8_t *)(uintptr_t)MEM_BASE_ADDR;
////						unpack_i2s_frames_to_q31(dma_bytes, total_frames, gMicMonoBuffer);
//						unpack_i2s_frames_to_q31_le_safe(dma_bytes, total_frames, gMicMonoBuffer);
//						const int downsample_input = (int)required_frames;
//						downsample_6x_avg(gMicMonoBuffer + offset_frames, gKwsInputBuffer, downsample_input);
//						xil_printf("\r\n    sampling done");
//
//						u32 classIndex = 0U;
//						float confidence = 0.0f;
//						// 保存处理后的文件
//						FRESULT fr;
//						char filename[64];
//
//						/* 挂载 SD 卡 */
//						fr = f_mount(&fs, "0:/", 1);
//						if (fr != FR_OK) {
//							xil_printf("\r\n[SD] Mount failed (%d)\r\n", fr);
//						} else {
//							// 2. 打开或创建文件 record.raw（覆盖写）
//							fr = f_open(&fil, "0:/record.raw", FA_CREATE_ALWAYS | FA_WRITE);
//							if (fr == FR_OK) {
//								UINT bw;
//								const BYTE *dma_bytes = (const BYTE *)(uintptr_t)gKwsInputBuffer;
//								UINT total_bytes = NR_KWS_SAMPLES * sizeof(int32_t);
//
//								Xil_DCacheInvalidateRange((UINTPTR)dma_bytes, total_bytes);
//								fr = f_write(&fil, dma_bytes, total_bytes, &bw);
//
//								if (fr == FR_OK && bw == total_bytes) {
//									xil_printf("\r\n[SD] Saved raw audio: record.raw (%lu bytes)\r\n",
//											   (unsigned long)bw);
//								} else {
//									xil_printf("\r\n[SD] Write failed (%d), written %lu bytes\r\n",
//											   fr, (unsigned long)bw);
//								}
//
//								f_close(&fil);
//							} else {
//								xil_printf("\r\n[SD] Open file failed (%d)\r\n", fr);
//							}
//						}
//						//
//						// 处理KWS
//						Status = KwsEngine_ProcessRecording(gKwsInputBuffer,
//							NR_KWS_SAMPLES,
//							&classIndex,
//							&confidence);
//						// 亮灯
//						int led = classIndex - 2;
//						if (led<=0) {
//							led = 0;
//						}
//						fnSetSingleLed(&sUserIO, 2);
//						if (Status == XST_SUCCESS)
//						{
//							int scaled = (int)(confidence * 10000.0f + 0.5f);
//							Demo.u32KwsClass = classIndex;
//							Demo.fKwsConfidence = confidence;
//							Demo.fKwsResultValid = 1;
//							xil_printf("\r\nKWS inference: class %lu (confidence %d.%02d%%)",
//								(unsigned long)classIndex,
//								scaled / 100,
//								scaled % 100);
//						}
//						else
//						{
//							xil_printf("\r\nKWS inference failed");
//							Demo.fKwsResultValid = 0;
//						}
//						// 直接播放
//						xil_printf("\r\nStart Playback...\r\n");
//						fnSetHpOutput();
//						usleep(100000); // 寤惰繜100ms锛岃妯℃嫙鍓嶇绋冲畾
//						//
////    							fnAudioPlay(sAxiDma,AUDIO_SAMPLING_RATE);
//						fnAudioPlay(sAxiDma,NR_AUDIO_SAMPLES);
//					}
//					else
//					{
//						xil_printf("\r\nInsufficient microphone audio: have %lu frames, need %lu\r\n",
//							(unsigned long)available_frames,
//							(unsigned long)required_frames);
//						Demo.fKwsResultValid = 0;
//					}
//				}
//				else
//				{
//					xil_printf("\r\nKWS engine not ready; skipping inference\r\n");
//					Demo.fKwsResultValid = 0;
//				}
//
//				// Reset S2MM event and record flag
//				Demo.fDmaS2MMEvent = 0;
//				Demo.fAudioRecord = 0;
//		}
//
//		// Checking the DMA MM2S event flag
//    			if (Demo.fDmaMM2SEvent)
//    			{
//    				xil_printf("\r\nPlayback Done...");
//
//    				// Disable Stream function to send data (S2MM)
//    				Xil_Out32(I2S_STREAM_CONTROL_REG, 0x00000000);
//    				Xil_Out32(I2S_TRANSFER_CONTROL_REG, 0x00000000);
//    				//Flush cache
////					//microblaze_flush_dcache();
//    				//Xil_DCacheFlushRange((u32) MEM_BASE_ADDR, 5*NR_AUDIO_SAMPLES);
//    				// Reset MM2S event and playback flag
//    				Demo.fDmaMM2SEvent = 0;
//    				Demo.fAudioPlayback = 0;
//    			}
//
//    			// Checking the DMA Error event flag
//    			if (Demo.fDmaError)
//    			{
//    				xil_printf("\r\nDma Error...");
//    				xil_printf("\r\nDma Reset...");
//
//
//    				Demo.fDmaError = 0;
//    				Demo.fAudioPlayback = 0;
//    				Demo.fAudioRecord = 0;
//    			}
//
//    			// Checking the btn change event
//    			if(Demo.fUserIOEvent) {
//
//    				switch(Demo.chBtn) {
//    					case 'u':
//    						if (!Demo.fAudioRecord && !Demo.fAudioPlayback)
//    						{
//    							xil_printf("\r\nStart Recording...\r\n");
//    							fnSetMicInput();
//    							usleep(100000); // 寤惰繜100ms锛岃妯℃嫙鍓嶇绋冲畾
//    							fnAudioRecord(sAxiDma,NR_AUDIO_SAMPLES);
////    							fnAudioRecord(sAxiDma,AUDIO_SAMPLING_RATE);
//    							Demo.fAudioRecord = 1;
//    						}
//    						else
//    						{
//    							if (Demo.fAudioRecord)
//    							{
//    								xil_printf("\r\nStill Recording...\r\n");
//    							}
//    							else
//    							{
//    								xil_printf("\r\nStill Playing back...\r\n");
//    							}
//    						}
//    						break;
//    					case 'd':
//    						if (!Demo.fAudioRecord && !Demo.fAudioPlayback)
//    						{
//    							xil_printf("\r\nStart Playback...\r\n");
//    							fnSetHpOutput();
//    							usleep(100000); // 寤惰繜100ms锛岃妯℃嫙鍓嶇绋冲畾
//    							//
////    							fnAudioPlay(sAxiDma,AUDIO_SAMPLING_RATE);
//    							fnAudioPlay(sAxiDma,NR_AUDIO_SAMPLES);
//    							Demo.fAudioPlayback = 1;
//    							//
//    							// 存SD卡
////    						    FRESULT fr;
////    						    char filename[64];
////
////    						    /* 挂载 SD 卡 */
////    						    fr = f_mount(&fs, "0:/", 1);
////    						    if (fr != FR_OK) {
////    						        xil_printf("\r\n[SD] Mount failed (%d)\r\n", fr);
////    						    } else {
////    						        // 2. 打开或创建文件 record.raw（覆盖写）
////    						        fr = f_open(&fil, "0:/record.raw", FA_CREATE_ALWAYS | FA_WRITE);
////    						        if (fr == FR_OK) {
////    						            UINT bw;
////    						            const BYTE *dma_bytes = (const BYTE *)(uintptr_t)MEM_BASE_ADDR;
////    						            UINT total_bytes = KWS_DMA_TRANSFER_BYTES;
////
////    						            Xil_DCacheInvalidateRange((UINTPTR)dma_bytes, total_bytes);
////    						            fr = f_write(&fil, dma_bytes, total_bytes, &bw);
////
////    						            if (fr == FR_OK && bw == total_bytes) {
////    						                xil_printf("\r\n[SD] Saved raw audio: record.raw (%lu bytes)\r\n",
////    						                           (unsigned long)bw);
////    						            } else {
////    						                xil_printf("\r\n[SD] Write failed (%d), written %lu bytes\r\n",
////    						                           fr, (unsigned long)bw);
////    						            }
////
////    						            f_close(&fil);
////    						        } else {
////    						            xil_printf("\r\n[SD] Open file failed (%d)\r\n", fr);
////    						        }
////    						    }
//    						    //
//    						    //
//    						}
//    						else
//    						{
//    							if (Demo.fAudioRecord)
//    							{
//    								xil_printf("\r\nStill Recording...\r\n");
//    							}
//    							else
//    							{
//    								xil_printf("\r\nStill Playing back...\r\n");
//    							}
//    						}
//    						break;
//    					case 'r':
//    						if (!Demo.fAudioRecord && !Demo.fAudioPlayback)
//    						{
//    							xil_printf("\r\nStart Recording...\r\n");
//    							fnSetLineInput();
//    							fnAudioRecord(sAxiDma,NR_AUDIO_SAMPLES);
//    							Demo.fAudioRecord = 1;
//    						}
//    						else
//    						{
//    							if (Demo.fAudioRecord)
//    							{
//    								xil_printf("\r\nStill Recording...\r\n");
//    							}
//    							else
//    							{
//    								xil_printf("\r\nStill Playing back...\r\n");
//    							}
//    						}
//    						break;
//    					case 'l':
//    						if (!Demo.fAudioRecord && !Demo.fAudioPlayback)
//    						{
//    							xil_printf("\r\nStart Playback...");
//    							fnSetLineOutput();
//    							fnAudioPlay(sAxiDma,NR_AUDIO_SAMPLES);
//    							Demo.fAudioPlayback = 1;
//    						}
//    						else
//    						{
//    							if (Demo.fAudioRecord)
//    							{
//    								xil_printf("\r\nStill Recording...\r\n");
//    							}
//    							else
//    							{
//    								xil_printf("\r\nStill Playing back...\r\n");
//    							}
//    						}
//    						break;
//    					default:
//    						break;
//    				}
//
//    				// Reset the user I/O flag
//    				Demo.chBtn = 0;
//    				Demo.fUserIOEvent = 0;
//
//
//    			}
//    	//usleep(90000);
//    }
//
//	xil_printf("\r\n--- Exiting main() --- \r\n");
//
//
//	return XST_SUCCESS;
//
//}
//
/******************************************************************************/
/*  demo.c -- Zynq DMA + Audio + KWS (python-like preprocessing)              */
/******************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <math.h>

#include "xparameters.h"
#include "xil_printf.h"
#include "xil_cache.h"
#include "sleep.h"

#include "ff.h"

#include "./audio/audio.h"
#include "./dma/dma.h"
#include "./intc/intc.h"
#include "./userio/userio.h"
#include "./iic/iic.h"
#include "./kws/kws_engine.h"

#ifdef XPAR_INTC_0_DEVICE_ID
 #include "xintc.h"
#else
 #include "xscugic.h"
#endif

/* 有些 BSP 的 math.h 没有 M_PI，手动补一下 */
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

/* ===================== 和原工程里一样的 Demo 全局 ===================== */
extern volatile sDemo_t Demo;

/* ===================== SD 卡全局 ===================== */
static FATFS fs;
static FIL  fil;

/* ===================== 采样、时长、数组大小：全都写成整数 ===================== */

/* I2S 一帧 5 字节：L 20bit + R 20bit */
#define I2S_BYTES_PER_FRAME     5U

/* 板子录到的原始采样率：和 Python 的 SOURCE_SR = 96000 对齐 */
#define AUDIO_SAMPLING_RATE     96000

/* 录制 2 s 音频 */
#define NR_AUDIO_SAMPLES        (2 * AUDIO_SAMPLING_RATE)  /* 192000 帧 */

/* 截取 0.5 s ~ 1.5 s 的片段 => 从第 0.5s * 96k 开始截取 1 s 数据 */
#define START_OFFSET_S          0.5f
#define SEGMENT_DURATION_S      1.0f
#define OFFSET_FRAMES           ((int)(AUDIO_SAMPLING_RATE * START_OFFSET_S))  /* 48000 */
#define SEGMENT_FRAMES          ((int)(AUDIO_SAMPLING_RATE * SEGMENT_DURATION_S))  /* 96000 */


/* KWS 这边目标采样率：对应 Python 的 TARGET_SR = 16000 */
#define KWS_TARGET_SR           16000

/* KWS 需要的就是“1秒 x 16k”的数据 */
#define NR_KWS_SAMPLES          KWS_TARGET_SR

/* 96k → 16k 是整除 6 */
#define DOWNSAMPLE_RATIO        6

#define I2S_BYTES_PER_FRAME     5U
#define AUDIO_SAMPLING_RATE     96000

#define NR_AUDIO_SAMPLES        (2 * AUDIO_SAMPLING_RATE)  /* 192000 帧 */
#define START_OFFSET_S          0.5f
#define SEGMENT_DURATION_S      1.0f
#define OFFSET_FRAMES           ((int)(AUDIO_SAMPLING_RATE * START_OFFSET_S))  /* 48000 */
#define SEGMENT_FRAMES          ((int)(AUDIO_SAMPLING_RATE * SEGMENT_DURATION_S))  /* 96000 */

#define KWS_TARGET_SR           16000
#define NR_KWS_SAMPLES          KWS_TARGET_SR
#define DOWNSAMPLE_RATIO        6
#define KWS_DMA_TRANSFER_BYTES  (I2S_BYTES_PER_FRAME * NR_AUDIO_SAMPLES)


/* DMA 实际要搬的字节数：105600 帧 × 5 字节 */
#define KWS_DMA_TRANSFER_BYTES  (I2S_BYTES_PER_FRAME * NR_AUDIO_SAMPLES)

/* SD 上保存预处理后 16k 的文件名 */
#define KWS_PROC_RAW_PATH       "0:/record.raw"

/* 打印调试前多少个点 */
#define DBG_LEN                 32

/* ===================== 全局 buffer（现在都是编译期常量了） ===================== */
/* 解包 + 合并后得到的 96k 单声道 */
static int32_t gMicMono96k[NR_AUDIO_SAMPLES];
/* 96k→16k 后的 1s@16k, int32 */
static int32_t gKws16k[NR_KWS_SAMPLES];
/* 做完高通+软门限后的 1s@16k */
static int32_t gKws16k_proc[NR_KWS_SAMPLES];

/* ===================== 中断控制器实例 ===================== */
#ifdef XPAR_INTC_0_DEVICE_ID
static XIntc   sIntc;
#else
static XScuGic sIntc;
#endif

static XIic    sIic;
static XAxiDma sAxiDma;
static XGpio   sUserIO;

/* ===================== 中断向量表 ===================== */
#ifdef XPAR_INTC_0_DEVICE_ID
const ivt_t ivt[] = {
    {XPAR_AXI_INTC_0_AXI_IIC_0_IIC2INTC_IRPT_INTR,
        (XInterruptHandler)XIic_InterruptHandler, &sIic},
    {XPAR_AXI_INTC_0_AXI_DMA_0_S2MM_INTROUT_INTR,
        (XInterruptHandler)fnS2MMInterruptHandler, &sAxiDma},
    {XPAR_AXI_INTC_0_AXI_DMA_0_MM2S_INTROUT_INTR,
        (XInterruptHandler)fnMM2SInterruptHandler, &sAxiDma},
    {XPAR_AXI_INTC_0_AXI_GPIO_0_IP2INTC_IRPT_INTR,
        (XInterruptHandler)fnUserIOIsr, &sUserIO}
};
#else
const ivt_t ivt[] = {
    {XPAR_FABRIC_AXI_IIC_0_IIC2INTC_IRPT_INTR,
        (Xil_ExceptionHandler)XIic_InterruptHandler, &sIic},
    {XPAR_FABRIC_AXI_DMA_0_S2MM_INTROUT_INTR,
        (Xil_ExceptionHandler)fnS2MMInterruptHandler, &sAxiDma},
    {XPAR_FABRIC_AXI_DMA_0_MM2S_INTROUT_INTR,
        (Xil_ExceptionHandler)fnMM2SInterruptHandler, &sAxiDma},
    {XPAR_FABRIC_AXI_GPIO_0_IP2INTC_IRPT_INTR,
        (Xil_ExceptionHandler)fnUserIOIsr, &sUserIO}
};
#endif

/* ===================== 小工具：点亮单个 LED ===================== */
static void fnSetSingleLed(XGpio *psGpio, u8 ledIndex)
{
    u32 led_value = 0;
    if (ledIndex < 8) {
        led_value = (1U << ledIndex);
    }
    XGpio_DiscreteWrite(psGpio, LED_CHANNEL, led_value);
}

/* ===================== 20bit 符号扩展 ===================== */
static int32_t sign_extend_20bit(uint32_t v)
{
    if (v & 0x80000U) {
        v |= 0xFFF00000U;
    }
    return (int32_t)v;
}

/* ===================== I2S 解包 + 双声道合并成单声道 ===================== */
static void unpack_i2s_frames_to_q31_le_safe(const uint8_t *src,
                                             size_t frames,
                                             int32_t *dst)
{
    if (frames == 0U) return;

    uint8_t b0 = src[0];
    uint8_t b4 = src[4];
    int reversed = (b0 < b4);   /* 简单经验判断 */

    for (size_t i = 0; i < frames; ++i) {
        size_t idx = i * I2S_BYTES_PER_FRAME;
        uint32_t B0,B1,B2,B3,B4;
        if (!reversed) {
            B0 = src[idx + 0];
            B1 = src[idx + 1];
            B2 = src[idx + 2];
            B3 = src[idx + 3];
            B4 = src[idx + 4];
        } else {
            B4 = src[idx + 0];
            B3 = src[idx + 1];
            B2 = src[idx + 2];
            B1 = src[idx + 3];
            B0 = src[idx + 4];
        }

        uint32_t left_u  = (B0 << 12) | (B1 << 4) | (B2 >> 4);
        uint32_t right_u = ((B2 & 0x0F) << 16) | (B3 << 8) | B4;

        int32_t left  = sign_extend_20bit(left_u)  << 12;  /* 放大到 Q31-ish */
        int32_t right = sign_extend_20bit(right_u) << 12;

        int64_t mono = ((int64_t)left + (int64_t)right) / 2;
        dst[i] = (int32_t)mono;
    }
}

/* ===================== 96k → 16k: 6 点平均 ===================== */
static void downsample_6x_avg(const int32_t *in, int32_t *out, int input_samples)
{
    int out_samples = input_samples / DOWNSAMPLE_RATIO;
    for (int i = 0; i < out_samples; ++i) {
        int64_t acc = 0;
        for (int j = 0; j < DOWNSAMPLE_RATIO; ++j) {
            acc += in[i * DOWNSAMPLE_RATIO + j];
        }
        out[i] = (int32_t)(acc / DOWNSAMPLE_RATIO);
    }
}

/* ===================== Debug 打印 ===================== */
static void dump_int32(const char *tag, const int32_t *buf, int n)
{
    xil_printf("\r\n[DBG] %s:\r\n", tag);
    for (int i = 0; i < n; ++i) {
        xil_printf("%d ", buf[i]);
    }
    xil_printf("\r\n");
}

static void dump_float(const char *tag, const float *buf, int n)
{
    xil_printf("\r\n[DBG] %s:\r\n", tag);
    for (int i = 0; i < n; ++i) {
        xil_printf("%0.6f ", buf[i]);
    }
    xil_printf("\r\n");
}

/* ===================== Biquad 高通 ===================== */
typedef struct {
    float b0,b1,b2;
    float a1,a2;
    float z1,z2;
} Biquad;

static void biquad_init_highpass(Biquad *st, float fs, float fc, float q)
{
    float w0   = 2.0f * (float)M_PI * fc / fs;
    float cs   = cosf(w0);
    float sn   = sinf(w0);
    float alpha = sn / (2.0f * q);

    float b0 =  (1.0f + cs) * 0.5f;
    float b1 = -(1.0f + cs);
    float b2 =  (1.0f + cs) * 0.5f;
    float a0 =   1.0f + alpha;
    float a1 =  -2.0f * cs;
    float a2 =   1.0f - alpha;

    st->b0 = b0 / a0;
    st->b1 = b1 / a0;
    st->b2 = b2 / a0;
    st->a1 = a1 / a0;
    st->a2 = a2 / a0;
    st->z1 = 0.0f;
    st->z2 = 0.0f;
}

static void biquad_process(Biquad *st, const float *in, float *out, int n)
{
    float z1 = st->z1;
    float z2 = st->z2;
    float b0 = st->b0;
    float b1 = st->b1;
    float b2 = st->b2;
    float a1 = st->a1;
    float a2 = st->a2;

    for (int i = 0; i < n; ++i) {
        float x = in[i];
        float y = b0 * x + z1;
        z1 = b1 * x + z2 - a1 * y;
        z2 = b2 * x - a2 * y;
        out[i] = y;
    }
    st->z1 = z1;
    st->z2 = z2;
}

/* ===================== 和 python simple_denoise 一致的预处理 ===================== */
static void kws_preprocess_int32_like_python(const int32_t *in16k,
                                             int32_t *out16k,
                                             int n_samples,
                                             int sample_rate)
{
    /* 这些现在是固定 16000 了，编译期常量，能过编译 */
    static float f_in[NR_KWS_SAMPLES];
    static float f_hp[NR_KWS_SAMPLES];
    static float f_out[NR_KWS_SAMPLES];

    const float scale = 1.0f / 2147483648.0f;
    for (int i = 0; i < n_samples; ++i) {
        f_in[i] = (float)in16k[i] * scale;
    }
    dump_float("stage2_after_downsample(float)", f_in,
               (n_samples > DBG_LEN) ? DBG_LEN : n_samples);

    Biquad hp;
    biquad_init_highpass(&hp, (float)sample_rate, 100.0f, 0.7071f);
    biquad_process(&hp, f_in, f_hp, n_samples);
    dump_float("stage3_after_highpass", f_hp,
               (n_samples > DBG_LEN) ? DBG_LEN : n_samples);

    int noise_len = sample_rate / 5;  /* 0.2s = 1/5 秒 */
    if (noise_len > n_samples) noise_len = n_samples;
    float noise_sum = 0.0f;
    for (int i = 0; i < noise_len; ++i) {
        float v = f_hp[i];
        if (v < 0) v = -v;
        noise_sum += v;
    }
    float noise_level = (noise_len > 0) ? (noise_sum / (float)noise_len) : 0.0f;
    float thresh = noise_level * 1.5f;
    xil_printf("\r\n[DBG] noise_len=%d noise_level=%0.6f thresh=%0.6f\r\n",
               noise_len, noise_level, thresh);

    for (int i = 0; i < n_samples; ++i) {
        float v = f_hp[i];
        float av = (v >= 0.0f) ? v : -v;
        if (av < thresh) {
            v = v * 0.3f;
        }
        f_out[i] = v;
    }
    dump_float("stage4_after_softgate", f_out,
               (n_samples > DBG_LEN) ? DBG_LEN : n_samples);

    for (int i = 0; i < n_samples; ++i) {
        float v = f_out[i];
        if (v > 1.0f)  v = 1.0f;
        if (v < -1.0f) v = -1.0f;
        out16k[i] = (int32_t)(v * 2147483647.0f);
    }
    dump_int32("stage5_final_int32_for_KWS", out16k,
               (n_samples > DBG_LEN) ? DBG_LEN : n_samples);
}

/* ===================== 存一份到 SD ===================== */
static void save_16k_int32_to_sd(const char *path,
                                 const int32_t *buf,
                                 size_t samples)
{
    FRESULT fr = f_mount(&fs, "0:/", 1);
    if (fr != FR_OK) {
        xil_printf("\r\n[SD] mount failed (%d)\r\n", fr);
        return;
    }

    fr = f_open(&fil, path, FA_CREATE_ALWAYS | FA_WRITE);
    if (fr != FR_OK) {
        xil_printf("\r\n[SD] open %s failed (%d)\r\n", path, fr);
        return;
    }

    UINT to_write = (UINT)(samples * sizeof(int32_t));
    UINT bw = 0;
    Xil_DCacheInvalidateRange((UINTPTR)buf, to_write);
    fr = f_write(&fil, (const void *)buf, to_write, &bw);
    f_close(&fil);

    if (fr == FR_OK && bw == to_write) {
        xil_printf("\r\n[SD] saved %s (%lu bytes)\r\n",
                   path, (unsigned long)bw);
    } else {
        xil_printf("\r\n[SD] write %s failed (%d), written %lu bytes\r\n",
                   path, fr, (unsigned long)bw);
    }
}

/* ===================== main ===================== */
int main(void)
{
    int Status;

    Demo.u8Verbose        = 1;
    Demo.fKwsEngineReady  = 0;
    Demo.fKwsResultValid  = 0;
    Demo.u32KwsClass      = 0;
    Demo.fKwsConfidence   = 0.0f;

    xil_printf("\r\n--- Entering main() ---\r\n");

    /* init interrupt controller */
#ifdef XPAR_INTC_0_DEVICE_ID
    Status = fnInitInterruptController(&sIntc);
#else
    Status = fnInitInterruptController(&sIntc);
#endif
    if (Status != XST_SUCCESS) {
        xil_printf("Interrupt init failed\r\n");
        return XST_FAILURE;
    }

    /* init i2c / userio / dma / audio */
    if (fnInitIic(&sIic) != XST_SUCCESS) {
        xil_printf("I2C init failed\r\n");
        return XST_FAILURE;
    }
    if (fnInitUserIO(&sUserIO) != XST_SUCCESS) {
        xil_printf("UserIO init failed\r\n");
        return XST_FAILURE;
    }
    if (fnConfigDma(&sAxiDma) != XST_SUCCESS) {
        xil_printf("DMA init failed\r\n");
        return XST_FAILURE;
    }
    if (fnInitAudio() != XST_SUCCESS) {
        xil_printf("Audio init failed\r\n");
        return XST_FAILURE;
    }

    /* enable interrupts */
    fnEnableInterrupts(&sIntc, &ivt[0], sizeof(ivt)/sizeof(ivt[0]));

    /* init KWS engine */
    Status = KwsEngine_Initialize(KWS_DEFAULT_WEIGHT_PATH);
    if (Status == XST_SUCCESS) {
        Demo.fKwsEngineReady = 1;
        xil_printf("\r\nKWS engine init OK\r\n");
    } else {
        xil_printf("\r\nKWS engine init FAILED\r\n");
        return Status;
    }

    xil_printf("\r\nPress BTNU to record 1.1s@96k, preprocess, run KWS\r\n");

    while (1) {
        if (Demo.fDmaS2MMEvent) {
            xil_printf("\r\n[DMA] Recording done\r\n");

            /* stop I2S */
            Xil_Out32(I2S_STREAM_CONTROL_REG,   0x00000000);
            Xil_Out32(I2S_TRANSFER_CONTROL_REG, 0x00000000);

            /* make sure DDR is visible */
            Xil_DCacheInvalidateRange((UINTPTR)MEM_BASE_ADDR, KWS_DMA_TRANSFER_BYTES);

            if ((Demo.fKwsEngineReady != 0U) && (KwsEngine_IsReady() != 0U)) {

            	const size_t total_frames = KWS_DMA_TRANSFER_BYTES / I2S_BYTES_PER_FRAME;
            	const size_t avail_frames = (total_frames > OFFSET_FRAMES)
            	                            ? (total_frames - OFFSET_FRAMES) : 0U;
            	const size_t need_frames  = SEGMENT_FRAMES;   /* 我们只用中间 1 s（96 000 帧） */


                xil_printf("[DBG] total=%lu, offset=%lu, avail=%lu, need=%lu\r\n",
                           (unsigned long)total_frames,
                           (unsigned long)OFFSET_FRAMES,
                           (unsigned long)avail_frames,
                           (unsigned long)need_frames);

                if (avail_frames >= need_frames) {
                    /* 解包 96k 双声道 → 96k 单声道 */
                    const uint8_t *dma_bytes = (const uint8_t *)(uintptr_t)MEM_BASE_ADDR;
                    unpack_i2s_frames_to_q31_le_safe(dma_bytes,
                                                     total_frames,
                                                     gMicMono96k);
                    dump_int32("stage0_after_unpack(96k)", gMicMono96k,
                               (NR_AUDIO_SAMPLES > DBG_LEN) ? DBG_LEN : NR_AUDIO_SAMPLES);

                    /* 丢掉前 0.1s (9600 帧)，再 6x 降采样到 16k */
                    downsample_6x_avg(gMicMono96k + OFFSET_FRAMES,
                                      gKws16k,
                                      (int)need_frames);
                    dump_int32("stage1_after_downsample(16k)", gKws16k,
                               (NR_KWS_SAMPLES > DBG_LEN) ? DBG_LEN : NR_KWS_SAMPLES);

                    /* 做 python 的 simple_denoise */
                    kws_preprocess_int32_like_python(gKws16k,
                                                     gKws16k_proc,
                                                     NR_KWS_SAMPLES,
                                                     KWS_TARGET_SR);

                    /* 存到 SD 给你回 PC 对拍 */
                    save_16k_int32_to_sd(KWS_PROC_RAW_PATH,
                                         gKws16k_proc,
                                         NR_KWS_SAMPLES);

                    /* 喂 KWS */
                    u32   cls  = 0U;
                    float conf = 0.0f;
                    Status = KwsEngine_ProcessRecording(gKws16k_proc,
                                                        NR_KWS_SAMPLES,
                                                        &cls,
                                                        &conf);
                    if (Status == XST_SUCCESS) {
                        int scaled = (int)(conf * 10000.0f + 0.5f);
                        xil_printf("\r\nKWS: class=%lu, conf=%d.%02d%%\r\n",
                                   (unsigned long)cls,
                                   scaled/100, scaled%100);
                        fnSetSingleLed(&sUserIO, 2);
                    } else {
                        xil_printf("\r\nKWS inference failed\r\n");
                    }

                    /* 播放一遍原始录到的 1.1s(可选) */
                    xil_printf("\r\nPlayback...\r\n");
                    fnSetHpOutput();
                    usleep(100000);
                    fnAudioPlay(sAxiDma, NR_AUDIO_SAMPLES);

                } else {
                    xil_printf("\r\n[ERR] not enough frames for 1s@16k\r\n");
                }

            } else {
                xil_printf("\r\n[ERR] KWS engine not ready\r\n");
            }

            Demo.fDmaS2MMEvent = 0;
            Demo.fAudioRecord  = 0;
        }

        /* 播放完成 */
        if (Demo.fDmaMM2SEvent) {
            xil_printf("\r\nPlayback done\r\n");
            Xil_Out32(I2S_STREAM_CONTROL_REG,   0x00000000);
            Xil_Out32(I2S_TRANSFER_CONTROL_REG, 0x00000000);
            Demo.fDmaMM2SEvent  = 0;
            Demo.fAudioPlayback = 0;
        }

        /* 按键事件 */
        if (Demo.fUserIOEvent) {
            switch (Demo.chBtn) {
            case 'u': /* 录音 */
                if (!Demo.fAudioRecord && !Demo.fAudioPlayback) {
                    xil_printf("\r\nStart Recording...\r\n");
                    fnSetMicInput();
                    usleep(100000);
                    fnAudioRecord(sAxiDma, NR_AUDIO_SAMPLES);
                    Demo.fAudioRecord = 1;
                }
                break;
            case 'd': /* 播放 */
                if (!Demo.fAudioRecord && !Demo.fAudioPlayback) {
                    xil_printf("\r\nStart Playback...\r\n");
                    fnSetHpOutput();
                    usleep(100000);
                    fnAudioPlay(sAxiDma, NR_AUDIO_SAMPLES);
                    Demo.fAudioPlayback = 1;
                }
                break;
            default:
                break;
            }
            Demo.fUserIOEvent = 0;
            Demo.chBtn        = 0;
        }
    }

    return 0;
}

