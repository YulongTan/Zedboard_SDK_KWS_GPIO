/************************************************************************/
/*  demo.c -- Zynq DMA + I2S + KWS Demo (16 kHz single-channel input)  */
/************************************************************************/

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "xparameters.h"
#include "xil_printf.h"
#include "xil_cache.h"
#include "sleep.h"
#include "ff.h"

#include "./audio/audio.h"
#include "./dma/dma.h"
#include "./intc/intc.h"
#include "./userio/userio.h"
#include "./iic/iic.h"
#include "./kws/kws_engine.h"
#include "xtime_l.h"

#ifdef XPAR_INTC_0_DEVICE_ID
 #include "xintc.h"
#else
 #include "xscugic.h"
#endif

/* ================================================================ */
/*                     全局常量配置                                 */
/* ================================================================ */
//#define I2S_BYTES_PER_FRAME     5U
// 修改为4U
#define I2S_BYTES_PER_FRAME     4U
#define AUDIO_SAMPLING_RATE     96000
#define KWS_TARGET_SR           16000
#define NR_KWS_SAMPLES          KWS_TARGET_SR
// 时间
#define NR_AUDIO_TIME_OFF          0.5 // 舍掉前面0.5s的时间
#define NR_AUDIO_TIME_KWS          1   // kws推理需要的时间
#define NR_AUDIO_TIME_ALL          NR_AUDIO_TIME_OFF + NR_AUDIO_TIME_KWS  // 总的录音时间

// 后缀加kws则代表时间为1，ori则代表有前面的偏移，off则代表是前面的偏移量
#define NR_AUDIO_SAMPLES_1c_ori        1 * (NR_AUDIO_TIME_ALL * AUDIO_SAMPLING_RATE)   // 1.5s总的录音音频 单音道，用来作为测试使用

#define NR_AUDIO_SAMPLES_2c_ori  (int)(2 * (NR_AUDIO_TIME_ALL * AUDIO_SAMPLING_RATE))   // 1.5s总的录音音频 需要乘2代表左右声道
#define NR_AUDIO_SAMPLES_2c_off  (int)(2 * (NR_AUDIO_TIME_OFF * AUDIO_SAMPLING_RATE))   // 跳过前0.5 s 乘以2代表左右声道

//预处理
#define NR_AUDIO_SAMPLES_1c_kws        1 * (NR_AUDIO_TIME_KWS * AUDIO_SAMPLING_RATE)       // 1 s音频
#define NR_KWS_SAMPLES_1c_kws          1 * (NR_AUDIO_TIME_KWS * NR_KWS_SAMPLES)

#define DOWNSAMPLE_RATIO        6
// DMA 总传输字节
#define KWS_DMA_TRANSFER_BYTES  (I2S_BYTES_PER_FRAME * NR_AUDIO_SAMPLES_2c_ori)

/* ================================================================ */
/*                       全局变量                                   */
/* ================================================================ */
volatile sDemo_t Demo = {0};
//static FATFS fs; static FIL fil;
//static int32_t gMicMono96k[NR_AUDIO_SAMPLES_KWS]; // 1s音频输入，采样率为96K, 左右声道归一后的
//static int32_t gKws16k[NR_KWS_SAMPLES];       // kws音频输入
//static int16_t gKws16kPcm16[NR_KWS_SAMPLES];
//static int32_t gPlayback96k[SEGMENT_FRAMES];

static int32_t gMic_96k_2[NR_AUDIO_SAMPLES_2c_ori]; // 用来测试单双音道 1.5s
// 双通道变单通道
static int32_t gMic_96k_1[NR_AUDIO_SAMPLES_1c_kws]; // 单音道
static int32_t gMic_16k_1[NR_KWS_SAMPLES_1c_kws];

/* ================================================================ */
/*                   外设实例与中断向量表                            */
/* ================================================================ */
#ifdef XPAR_INTC_0_DEVICE_ID
static XIntc sIntc;
#else
static XScuGic sIntc;
#endif
static XIic    sIic;
static XAxiDma sAxiDma;
static XGpio   sUserIO;

#ifdef XPAR_INTC_0_DEVICE_ID
const ivt_t ivt[] = {
    {XPAR_AXI_INTC_0_AXI_IIC_0_IIC2INTC_IRPT_INTR, (XInterruptHandler)XIic_InterruptHandler, &sIic},
    {XPAR_AXI_INTC_0_AXI_DMA_0_S2MM_INTROUT_INTR,  (XInterruptHandler)fnS2MMInterruptHandler, &sAxiDma},
    {XPAR_AXI_INTC_0_AXI_DMA_0_MM2S_INTROUT_INTR,  (XInterruptHandler)fnMM2SInterruptHandler, &sAxiDma},
    {XPAR_AXI_INTC_0_AXI_GPIO_0_IP2INTC_IRPT_INTR, (XInterruptHandler)fnUserIOIsr, &sUserIO}
};
#else
const ivt_t ivt[] = {
    {XPAR_FABRIC_AXI_IIC_0_IIC2INTC_IRPT_INTR, (Xil_ExceptionHandler)XIic_InterruptHandler, &sIic},
    {XPAR_FABRIC_AXI_DMA_0_S2MM_INTROUT_INTR,  (Xil_ExceptionHandler)fnS2MMInterruptHandler, &sAxiDma},
    {XPAR_FABRIC_AXI_DMA_0_MM2S_INTROUT_INTR,  (Xil_ExceptionHandler)fnMM2SInterruptHandler, &sAxiDma},
    {XPAR_FABRIC_AXI_GPIO_0_IP2INTC_IRPT_INTR, (Xil_ExceptionHandler)fnUserIOIsr, &sUserIO}
};
#endif

/* ================================================================ */
/*                     实用函数                                     */
/* ================================================================ */
// 用来测试使用 通过mix_mode对左右声道进行处理来判断
static void test(const int32_t *src_ptr,
					   int32_t *dst_mono,
					   size_t total_bytes,
					   int mix_mode)
{
    for (size_t i = 0; i < total_bytes; ++i) {
        int32_t left  = src_ptr[2 * i + 0];
        int32_t right = src_ptr[2 * i + 1];

        int32_t mono_left;
        int32_t mono_right;
        if (mix_mode == 0){
        	mono_left = left;
        	mono_right = 0;
        }
        else if (mix_mode == 1){
        	mono_left = 0;
        	mono_right = right;
        }
        else{
            mono_left = (left >> 1) + (right >> 1);  // 避免溢出
            mono_right = (left >> 1) + (right >> 1);  // 避免溢出
        }
        dst_mono[2 * i + 0] = mono_left;
        dst_mono[2 * i + 1] = mono_right;
    }
}
// 混合声道加下采样
/**
 * @brief 从DMA内存中提取交错的左右声道，混合成单声道
 * @param src_ptr   DMA写入的基址 (MEM_BASE_ADDR)
 * @param dst_mono  输出单声道缓冲区 (int32_t[])
 * @param total_frames  总帧数 (L+R对数)
 * @param mix_mode  0=取左声道, 1=取右声道, 2=平均混合
 */
static void mix_stereo_to_mono(const int32_t *src_ptr,
                               int32_t *dst_mono,
                               size_t total_frames,
                               int mix_mode)
{
    for (size_t i = 0; i < total_frames; ++i) {
        int32_t left  = src_ptr[2 * i + 0];
        int32_t right = src_ptr[2 * i + 1];

        int32_t mono;
        if (mix_mode == 0)
            mono = left;
        else if (mix_mode == 1)
            mono = right;
        else
            mono = (left >> 1) + (right >> 1);  // 避免溢出
        dst_mono[i] = mono;
    }
}
/**
 * @brief 简单整数倍下采样（平均法或取样法）
 * @param in96k   输入信号（96k）
 * @param out16k  输出信号（16k）
 * @param n_in    输入样本数
 * @param ratio   下采样比例 (6或7)
 * @param use_avg 是否采用平均法 (1=平均, 0=取第一个点)
 */
static int downsample_int(const int32_t *in96k,
                           int32_t *out16k,
                           int n_in,
                           int ratio,
                           int use_avg)
{
    int out_n = n_in / ratio;
    for (int i = 0; i < out_n; ++i) {
        if (use_avg) {
            int64_t acc = 0;
            for (int j = 0; j < ratio; ++j)
                acc += in96k[i * ratio + j];
            out16k[i] = (int32_t)(acc / ratio);
        } else {
            out16k[i] = in96k[i * ratio];
        }
    }
   return out_n;
}

typedef struct __attribute__((__packed__)) {
    char     riff_id[4];
    uint32_t riff_size;
    char     wave_id[4];
    char     fmt_id[4];
    uint32_t fmt_size;
    uint16_t audio_format;
    uint16_t num_channels;
    uint32_t sample_rate;
    uint32_t byte_rate;
    uint16_t block_align;
    uint16_t bits_per_sample;
    char     data_id[4];
    uint32_t data_size;
} wav_header_t;

/* ================================================================ */
/*                       主程序入口                                 */
/* ================================================================ */
int main(void)
{
    xil_printf("\r\n--- Zynq Audio DMA + KWS Demo ---\r\n");

    if(fnInitInterruptController(&sIntc)!=XST_SUCCESS) return XST_FAILURE;
    if(fnInitIic(&sIic)!=XST_SUCCESS) return XST_FAILURE;
    if(fnInitUserIO(&sUserIO)!=XST_SUCCESS) return XST_FAILURE;
    if(fnConfigDma(&sAxiDma)!=XST_SUCCESS) return XST_FAILURE;
    if(fnInitAudio()!=XST_SUCCESS) return XST_FAILURE;
    fnEnableInterrupts(&sIntc,&ivt[0],sizeof(ivt)/sizeof(ivt[0]));

    if(KwsEngine_Initialize(KWS_DEFAULT_WEIGHT_PATH)!=XST_SUCCESS){
        xil_printf("KWS engine init failed\r\n"); return XST_FAILURE;
    }
    Demo.fKwsEngineReady=1; xil_printf("KWS engine ready\r\n");

    xil_printf("Press BTNU to record 1 s audio, auto-play & run KWS\r\n");
//    XTime tStart, tEnd;
//    int duration; // 计时
    while(1){
        /* ========== 录音完成 ========== */
        if(Demo.fDmaS2MMEvent){
            xil_printf("[DMA] Recording done\r\n");
            Xil_Out32(I2S_STREAM_CONTROL_REG,0);
            Xil_Out32(I2S_TRANSFER_CONTROL_REG,0);
            Xil_DCacheInvalidateRange((UINTPTR)MEM_BASE_ADDR,KWS_DMA_TRANSFER_BYTES);

//            const uint8_t *dma_bytes=(const uint8_t*)(uintptr_t)MEM_BASE_ADDR;
//            const size_t total_frames=KWS_DMA_TRANSFER_BYTES/I2S_BYTES_PER_FRAME;

            // 解包
//            unpack_i2s_frames_to_q31_le_safe(dma_bytes,total_frames,gMicMono96k);
            // 下采样
//            downsample_6x_avg(gMicMono96k+START_OFFSET_FRAMES,gKws16k,SEGMENT_FRAMES);
//             双通道改为单通道
            const int32_t *dma_samples =(const int32_t*)(uintptr_t)MEM_BASE_ADDR;
            int test_mix_mode = 1; // 0=左声道, 1=右声道, 2=混合
            test(dma_samples, gMic_96k_2, NR_AUDIO_SAMPLES_1c_ori, test_mix_mode);
            // 偏移后的基地址
            // 双通道变两通道
//            const int32_t *kws_samples = ((const int32_t*)(UINTPTR)MEM_BASE_ADDR) + NR_AUDIO_SAMPLES_2c_off;
//
//            int mix_mode = 0;
//            mix_stereo_to_mono(kws_samples, gMic_96k_1, NR_AUDIO_SAMPLES_1c_kws, mix_mode);
//            // 下采样
//            int down_load_mode = 0;
//
//            int out_dim = downsample_int(gMic_96k_1, gMic_16k_1, NR_AUDIO_SAMPLES_1c_kws, DOWNSAMPLE_RATIO, down_load_mode);
//            xil_printf("down load dim = %d \r\n", out_dim);
//            // 输入到KWS网络
//			/* KWS 推理 */
//			u32 cls=0; float conf=0.0f;
//			if(KwsEngine_ProcessRecording(gMic_16k_1,NR_KWS_SAMPLES,&cls,&conf)==XST_SUCCESS){
//				int scaled=(int)(conf*10000.0f+0.5f);
//				xil_printf("KWS: class=%lu, conf=%d.%02d%%\r\n",
//					(unsigned long)cls,scaled/100,scaled%100);
//				// 亮灯
//				fnSetSingleLed(&sUserIO,(cls-2)%8);
//			} else xil_printf("KWS inference failed\r\n");
//            const int32_t *dma_samples = (const int32_t*)(uintptr_t)MEM_BASE_ADDR + START_OFFSET_FRAMES * 2; //跳过前面0。5s音频，因为此时还是双音道，所以乘2
//
//            size_t total_lr_pairs = 2 * NR_AUDIO_SAMPLES;  // 1 frame = 1 left+right pair 2乘以总的采样点数
//            mix_stereo_to_mono(dma_samples, );
//
//            /* 自动播放：与 KWS 输入同一时间段 */
//            upsample_6x_for_playback(gKws16k,gPlayback96k,NR_KWS_SAMPLES);
//            UINTPTR playback_base = (UINTPTR)MEM_BASE_ADDR +
//                                   (UINTPTR)START_OFFSET_FRAMES * I2S_BYTES_PER_FRAME;
//            fnSetHpOutput();
//            usleep(100000);
//            fnAudioPlay(sAxiDma, playback_base, SEGMENT_FRAMES);


//            //添加查看的代码
//            uint32_t *p = (uint32_t *)(uintptr_t)MEM_BASE_ADDR;
//            for (int i = 0; i < 10; i++) {
//                xil_printf("[%d] L=%08x  R=%08x\r\n", i, p[2*i], p[2*i+1]);
//            }

//            xil_printf("\r\n[DMA] Dump first 64 bytes from MEM_BASE_ADDR = 0x%08X\r\n",
//                       (unsigned int)MEM_BASE_ADDR);
//            for (int i = 0; i < 64; i++) {
//                xil_printf("%02X ", p[i]);
//                if ((i & 0x0F) == 0x0F) xil_printf("\r\n");  // 每16字节换行
//            }

//
//            /* KWS 推理 */
//            u32 cls=0; float conf=0.0f;
//            if(KwsEngine_ProcessRecording(gKws16k,NR_KWS_SAMPLES,&cls,&conf)==XST_SUCCESS){
//                int scaled=(int)(conf*10000.0f+0.5f);
//                xil_printf("KWS: class=%lu, conf=%d.%02d%%\r\n",
//                    (unsigned long)cls,scaled/100,scaled%100);
//                fnSetSingleLed(&sUserIO,(cls-2)%8);
//            } else xil_printf("KWS inference failed\r\n");

            Demo.fDmaS2MMEvent=0; Demo.fAudioRecord=0;
        }

        /* ========== 播放完成 ========== */
        if(Demo.fDmaMM2SEvent){
            xil_printf("[PLAY] done\r\n");
            Xil_Out32(I2S_STREAM_CONTROL_REG,0);
            Xil_Out32(I2S_TRANSFER_CONTROL_REG,0);
//			XTime_GetTime(&tEnd);
//			duration = (int)((double)(tEnd - tStart) * 1000 / (COUNTS_PER_SECOND));
//			xil_printf("[Timer] Record duration = %d s\r\n", duration);
            Demo.fDmaMM2SEvent=0; Demo.fAudioPlayback=0;
        }

        /* ========== 按键事件 ========== */
        if(Demo.fUserIOEvent){
            if(Demo.chBtn=='u' && !Demo.fAudioRecord && !Demo.fAudioPlayback){
                xil_printf("Start Recording...\r\n");
                fnSetMicInput(); usleep(100000);
//                fnAudioRecord(sAxiDma,NR_AUDIO_SAMPLES);
                fnAudioRecord(sAxiDma,NR_AUDIO_SAMPLES_2c_ori);
                Demo.fAudioRecord=1;
            } else if(Demo.chBtn=='d' && !Demo.fAudioRecord && !Demo.fAudioPlayback){
                xil_printf("Start Playback...\r\n");
                fnSetHpOutput(); usleep(100000);
                //
//                XTime_GetTime(&tStart);
                fnAudioPlay(sAxiDma,(UINTPTR)gMic_96k_2,NR_AUDIO_SAMPLES_2c_ori);
                //
                Demo.fAudioPlayback=1;
            }
            Demo.fUserIOEvent=0; Demo.chBtn=0;
        }
    }
    return 0;
}

